<h1 id='tips-and-tricks'>Tips and Tricks</h1><h2 id='tips-and-tricks-using-run-on-a-server'>Using Run on a Server</h2>
<p>You may choose to use Run in a server environment. For example, you may:</p>

<ul>
<li>Index user jigs to allow searching in your app</li>
<li>Take actions automatically as in a game server</li>
<li>Gather statistics about your user&#39;s behaviors</li>
<li>Administrative tasks like managing a blacklist</li>
</ul>

<p>The architecture you choose will depend on your application. You might create a REST service using <code>express</code> that allows users to make requests. Or you might index all jigs using a Planaria crawler. Or you might deploy a serverless function that responds to events. Or perhaps a combination.</p>

<p>No matter the approach, you&#39;ll likely use Node on your servers. Run requires at least version 10 of Node. You can check which version you are using with <code>node --version</code>. If you are using Google Functions, be sure to set <code>{ &quot;engine&quot;: 10 }</code> in your <code>package.json</code>, because it defaults to Node 8.</p>

<p>Here are a few more tips:</p>
<h3 id='tips-and-tricks-using-run-on-a-server-increase-cache-limits'>Increase Cache Limits</h3>
<blockquote>
<p>Increase the mainnet blockchain cache size</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Run</span><span class="p">()</span>

<span class="nx">run</span><span class="p">.</span><span class="nx">blockchain</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">1000000</span>
</code></pre>
<p>The <code>BlockchainApi</code> caches transactions it fetches in memory. By default, it will cache 10,000 transactions. This is reasonable for clients, but on a server you should increase this limit by changing <code>run.blockchain.cache.size</code>.</p>

<blockquote>
<p>Increase the state cache size</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="nx">run</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">sizeMB</span> <span class="o">=</span> <span class="mi">1000</span>
</code></pre>
<p>The <code>StateCache</code> also caches jig state. By default, it caches 10MB of data in memory. This can be increased by setting <code>run.state.cache.sizeMB</code>. Alternatively, you also choose to <a href="#advanced-usage-using-run-on-a-server-persist-state">persist state</a> on disk rather than in memory.</p>

<p>After increasing these limits, you may also need to increase Node&#39;s memory limits. If you launch your server by starting node manually, you can increase its memory via: <code>node --max-old-space-size=8192</code>.</p>
<h3 id='tips-and-tricks-using-run-on-a-server-persist-state'>Persist State</h3>
<blockquote>
<p>Save state into a Firestore collection</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">Firestore</span> <span class="p">{</span>
  <span class="nx">async</span> <span class="nx">get</span><span class="p">(</span><span class="nx">location</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">entry</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">(</span><span class="s1">'state'</span><span class="p">).</span><span class="nx">doc</span><span class="p">(</span><span class="nx">location</span><span class="p">).</span><span class="nx">get</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">exists</span><span class="p">)</span> <span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">data</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">async</span> <span class="nx">set</span><span class="p">(</span><span class="nx">location</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">(</span><span class="s1">'state'</span><span class="p">).</span><span class="nx">doc</span><span class="p">(</span><span class="nx">location</span><span class="p">).</span><span class="nx">set</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">run</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Run</span><span class="p">({</span> <span class="na">state</span><span class="p">:</span> <span class="k">new</span> <span class="nx">Firestore</span><span class="p">()</span> <span class="p">})</span>
</code></pre>
<p>It is a good idea to persist your state in a database so your backend never needs to load the same jig twice. It is even more important when using multiple servers because you can share this database. Simply implement the <a href="#api-reference-apis-state">State</a> API.</p>

<p>Run will automatically call <code>get</code> on your <code>State</code> implementation when locations are requested, and <code>set</code> when the state is calculated. State will never change for a given location. Just implement these two methods to load and save state into your preferred key-value database: Redis, Firestore, DynamoDB, etc.</p>

<p>To the right is an example of persisting in Google Firestore.</p>
<h3 id='tips-and-tricks-using-run-on-a-server-avoid-race-conditions'>Avoid Race Conditions</h3>
<p>If you are seeing server errors about <code>Missing inputs</code> or <code>txn-mempool-conflict</code>, it is likely that you have encountered a race condition. Two pieces of code are likely attempting to update the same jig at the same time, and are attemping to spend the same Bitcoin outputs. The network can only accept one. To solve this, here are a few recommendations:</p>

<p><strong>Load jigs once at the start</strong>: If you have jigs you are reused across many request handlers, then load those jigs once upon starting your server, rather than loading them each time they are used. This will let Run track the output as a single object, and successive updates on that object will be correctly enqueued.</p>

<p><strong>Separate server, separate purses</strong>: Every Run instance has its own internal update queue, so it is unlikely that the purse will be double-spent on a single server. But on multiple servers, if a purse key is shared, then it is very likely that double-spend errors will occur. To avoid this, use different purse keys on different servers.</p>

<p><strong>Sync after every update</strong>: Call <code>await jig.sync()</code> on jigs after you call a method to be sure that the updates were applied before continuing on.</p>

<p><strong>Serialize risky updates</strong>: If a request handler makes updates to multiple jigs, and these updates can conflict if interleaved across multiple users, then consider serializing these updates. The most reliable approach is to bundle all jig updates together in a <a href="#advanced-usage-batch-transactions">batch</a>, so that the operation is all-or-nothing. An alternative is to put updates into a task queue like <code>p-limit</code>.</p>

<p><strong>Add retry logic</strong>: If the above changes do not fix a race condition, consider adding retry logic.</p>
<h3 id='tips-and-tricks-using-run-on-a-server-load-only-safe-code'>Load Only Safe Code</h3>
<p>Arbitrary code has the potential for infinite loops and infinite memory attacks that can take down your server. Avoid running code that you do not trust. Only load jigs that you expect are safe, and avoid executing arbitrary code without an admin&#39;s approval. And do not call <code>run.sync()</code>, because that will load UTXOs you receive from others. In the future, we will have tooling to handle these attacks and run arbitrary code, similar to how the Bitcoin SV node has a fast-path and a slow-path, but for now it is best to be safe.</p>
<h2 id='tips-and-tricks-limiting-supply'>Limiting Supply</h2><pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">Weapon</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span>
  <span class="nx">init</span><span class="p">(</span><span class="nx">owner</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">caller</span><span class="p">).</span><span class="nx">toBeInstanceOf</span><span class="p">(</span><span class="nx">GameItems</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">owner</span> <span class="o">=</span> <span class="nx">owner</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">GameItems</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span>
  <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">weaponCount</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="nx">createWeapon</span><span class="p">(</span><span class="nx">owner</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">owner</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">GameItems</span><span class="p">.</span><span class="nx">owner</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">weaponCount</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'too many weapons'</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Weapon</span><span class="p">(</span><span class="nx">owner</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">GameItems</span><span class="p">.</span><span class="nx">deps</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">Weapon</span><span class="p">,</span> <span class="nx">expect</span> <span class="p">}</span>
<span class="nx">Weapon</span><span class="p">.</span><span class="nx">deps</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">GameItems</span><span class="p">,</span> <span class="nx">expect</span> <span class="p">}</span>
</code></pre>
<p>The supply of a jig class may be limited through the use of a <em>minter</em>. The <em>minter</em> is a separate jig that regulates the number of <em>mintee</em> jigs produced. In the example on the right, the <code>GameItems</code> jig is the <em>minter</em> and is owned by the game. The <code>Weapon</code> jig is the <em>mintee</em> and is owned by a player. The <code>Weapon</code> class enforces that it can only be created by <code>GameItems</code>, and the <code>GameItems</code> class limits the supply of <code>Weapon</code>.</p>

<p>In <code>Weapon.init</code>, we check that the weapon is being created by a <code>GameItems</code> instance using the <a href="#advanced-usage-caller">caller</a> special property. <code>caller</code> is the jig that called the current method being executed. If a player tried to create a <code>Weapon</code> instance independent of <code>GameItems</code>, Run would throw an error because the <code>caller</code> property would be <code>null</code>.</p>

<p>In <code>GameItems</code>, we check that there are no more than 10 items created by the game in <code>createWeapon(owner)</code>. This limits the supply. However, we also have to check that <code>GameItems</code> is only able to be created by the game company. This is to prevent users from creating their own <code>GameItems</code> classes to mint their own weapons.</p>
<h2 id='tips-and-tricks-dynamic-whitelists'>Dynamic Whitelists</h2>
<blockquote>
<p>A dynamic whitelist to support new tokens over time</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">TokenWhitelist</span> <span class="p">{</span>
  <span class="nx">init</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">()</span> <span class="p">}</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">whitelist</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TokenWhitelist</span><span class="p">()</span>

<span class="kr">class</span> <span class="nx">Account</span> <span class="p">{</span>
  <span class="nx">init</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">deposits</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">()</span> <span class="p">}</span>

  <span class="nx">deposit</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">owner</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">owner</span><span class="p">)</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">Account</span><span class="p">.</span><span class="nx">whitelist</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">constructor</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">deposits</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Account</span><span class="p">.</span><span class="nx">whitelist</span> <span class="o">=</span> <span class="nx">whitelist</span> 
</code></pre>
<p>Often times an app will want to allow third-party developers to create new kinds of content. That content should freely interact with existing content once it is approved. For this, it&#39;s useful to have a dynamic whitelist of approved classes that jigs can check against. Jigs may store classes and functions like as any other data, and jigs may also be passed code as arguments into their methods. Combining these features, we can create a whitelist. </p>

<p>For example, an exchange may allow users to permissionally exchange any tokens approved on their site. To do this, we can approvers create whitelists. The owners of these whitelists will often be the apps themselves. See the example to the right 🠮</p>

<p>Similarly, as an app developer, you may want to revoke access to jigs you&#39;ve issued for security. One way to do this is for every revokable token to create a separate token owned by the party who can revoke it. Every action taken inside the token should check if it is revoked, and if so, throw an error.</p>
<h2 id='tips-and-tricks-upgrading-jigs'>Upgrading Jigs</h2>
<blockquote>
<p>Method 1: Reissuing Jigs</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">OriginalJig</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">UpgradedJig</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span> 
  <span class="nx">init</span><span class="p">(</span><span class="nx">original</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">original</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">!==</span> <span class="nx">OriginalJig</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'unexpected jig'</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">original</span> <span class="o">=</span> <span class="nx">original</span>
  <span class="p">}</span>
  <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">4</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<blockquote>
<p>Method 2: Replacing Behavior</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">class</span> <span class="nx">Weapon</span> <span class="kr">extends</span> <span class="nx">Jig</span> <span class="p">{</span>
  <span class="nx">setAttackBehavior</span><span class="p">(</span><span class="nx">attackFunction</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">attackFunction</span> <span class="o">=</span> <span class="nx">attackFunction</span>
  <span class="p">}</span>

  <span class="nx">attack</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">attackFunction</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">weapon</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Weapon</span><span class="p">()</span>

<span class="kd">function</span> <span class="nx">attackPlayer</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">player</span><span class="p">.</span><span class="nx">doDamage</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">weapon</span><span class="p">.</span><span class="nx">setAttackBehavior</span><span class="p">(</span><span class="nx">attackPlayer</span><span class="p">)</span>
<span class="nx">weapon</span><span class="p">.</span><span class="nx">attack</span><span class="p">(</span><span class="nx">player</span><span class="p">)</span>
</code></pre>
<p>By default, jig classes are not upgradable. However, you may simulate upgradability by creating a new jig that wraps the old one and adds the new behavior. You may also simulate upgradability by storing behavior in classes. These are both demonstrated on the right. There will be additional ways to upgrade classes in the future.</p>
<h2 id='tips-and-tricks-atomic-swaps'>Atomic Swaps</h2>
<blockquote>
<p>Atomically swapping two items with different owners</p>

<p>Machine 1</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">myWeapon</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="nx">weaponLocation</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">theirArmor</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="nx">armorLocation</span><span class="p">)</span>

<span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="nx">begin</span><span class="p">()</span>

<span class="kr">const</span> <span class="nx">me</span> <span class="o">=</span> <span class="nx">myWeapon</span><span class="p">.</span><span class="nx">owner</span>
<span class="nx">myWeapon</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">theirArmor</span><span class="p">.</span><span class="nx">owner</span><span class="p">)</span>
<span class="nx">theirArmor</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">me</span><span class="p">)</span>

<span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="nx">pay</span><span class="p">()</span>
<span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="nx">sign</span><span class="p">()</span>

<span class="kr">const</span> <span class="nx">tx</span> <span class="o">=</span> <span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="kr">export</span><span class="p">()</span>
</code></pre>
<blockquote>
<p>Machine 2</p>
</blockquote>
<pre class="highlight javascript tab-javascript"><code><span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="kr">import</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="nx">actions</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: Inspect the transaction to be sure it atomically swaps</span>
<span class="p">}</span>
<span class="nx">await</span> <span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="nx">sign</span><span class="p">()</span>

<span class="nx">run</span><span class="p">.</span><span class="nx">transaction</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
</code></pre>
<p>Run supports atomically updating jigs with different owners using the Transaction API. One application for this is atomic swaps, where two jigs owned by different users are exchanged in a single transaction.</p>

<p>The general process for an atomic swap is first for one user to start a Run transaction by calling <code>run.transaction.begin()</code>. Then, this user performs all updates, including calling methods on jigs they don&#39;t own. Run allows this user to build the transaction although they won&#39;t be able to add all of the signatures. Finally, this first user pays for the transaction and sign their jigs. The transaction is complete, and must now be handed to other parties for them to add their signatures. To do that, the first user calls <code>run.transaction.export()</code> to get the bsv transaction and sends it to the other parties via a separate channel.</p>

<p>The other party then calls <code>run.transaction.import()</code> to load the transaction they received. They may then want to check what the transaction does by inspecting <code>run.transaction.actions</code>. If they approve, then they may call <code>run.transaction.sign()</code> to add signatuers for their jigs. This process may continue for additional parties. When all signatures are collected, the last user calls <code>run.transaction.end()</code> to broadcast the transaction to the Bitcoin network.</p>

<p>The Transaction API may also be used to simulate state channels and propose changes to other jigs. See the <a href="#api-reference-transaction">Transaction API</a> for more information.</p>
<h2 id='tips-and-tricks-debugging'>Debugging</h2>
<p>Sometimes you will be faced with errors you don&#39;t understand. Don&#39;t fret! Here are some tips:</p>

<ul>
<li>Grab the latest Run SDK from <a href="https://www.runonbitcoin.com">runonbitcoin.com</a></li>
<li>Redeploy any jigs from older versions of Run</li>
<li>Use Node 10+ or a modern web browser like Chrome, Firefox, Edge, or Safari</li>
<li>Use the mockchain to check that it is not a connection or server-side error</li>
<li>Enable Run&#39;s internal logs by passing <code>{ logger: console }</code> into <code>Run</code></li>
<li>Disable sandboxing for your class by adding your class to the <code>Run.sandbox.excludes</code> array. (Note: This is not recommended in production)</li>
</ul>
<h3 id='tips-and-tricks-debugging-writing-unit-tests'>Writing Unit Tests</h3>
<p>It is always a good idea to write unit tests for your jigs. We recommend using a framework like <code>mocha</code> or <code>jest</code>, and running your tests using the mockchain. The mockchain will be faster and will isolate your Jig logic from any network errors.</p>
<h3 id='tips-and-tricks-debugging-too-long-mempool-chain'>too-long-mempool-chain</h3>
<p>If you see a <code>too-long-mempool-chain</code> error, it means that you&#39;ve hit a BSV network limitation. Today, only 25 transactions may be chained together in each Bitcoin block, and because of how Run works, you are likely to hit this in one of two ways:</p>

<ol>
<li>You update a jig 25 times in a ~10 minute block window</li>
<li>You create ~250 separate jigs in a ~10 minute block window using the same purse</li>
</ol>

<p>For #1, our best advice is to see if you can rearchitect your Jigs to avoid this case. We will provide a built-in solution in the future to avoid this limit.</p>

<p>For #2, we recommend switching between purses. Run automatically splits your UTXOs into 10 pieces, so you usually will be able to make over 200 transactions per block for each purse. You can increase this limit by setting <code>run.purse.splits = 100</code>.</p>
<h3 id='tips-and-tricks-debugging-getting-help'>Getting Help</h3>
<p>Please reach out to @niv in the BSV slack channels. We are happy to help you debug and fix any issues you encounter. If you can, see if you can reproduce the issue in the browser using <code>getting_started.html</code>.</p>
